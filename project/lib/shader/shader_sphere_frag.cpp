const char* shader_sphere_frag =

"//\n"
"// Fragment Shader\n"
"//\n"
"\n"
"uniform vec3  iResolution;\n"
"uniform vec3  iMouse;\n"
"uniform float iTime;\n"
"varying vec2  vTextVary;\n"
"\n"
"\n"
"\n"
"\n"
"#define MAX_MARCHES 32\n"
"#define MAX_DISTANCE 32.0\n"
"#define COLLISION_DISTANCE 0.01\n"
"#define Bailout 16.0\n"
"#define Iterations 6\n"
"\n"
"// Mandelbulb Distance Estimator\n"
"// Adapted from:\n"
"// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\n"
"float sphere(vec3 pos) {\n"
"	float Power = float((sin(iTime * 2.5) * 0.5) + 8.0);\n"
"	vec3 z = pos;\n"
"	float dr = 1.0;\n"
"	float r = 0.0;\n"
"	for (int i = 0; i < Iterations ; i++) {\n"
"		r = length(z);\n"
"		if (r>Bailout) break;\n"
"		\n"
"		// Convert to Polar Coordinates\n"
"		float theta = acos(z.z/r);\n"
"		float phi = atan(z.y,z.x);\n"
"		dr =  pow( r, Power-1.0)*Power*dr + 1.0;\n"
"		\n"
"		// Scale and Rotate the Point\n"
"		float zr = pow( r,Power);\n"
"		theta = theta*Power;\n"
"		phi = phi*Power;\n"
"		\n"
"		// Convert Back to Cartesian Coordinates\n"
"		z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n"
"		z+=pos;\n"
"	}\n"
"	return 0.5*log(r)*r/dr;\n"
"}\n"
"\n"
"// Compute/March the Ray\n"
"float raymarch(vec3 camerapos, vec3 raydir) {\n"
"	float distorigin=0.0;\n"
"    \n"
"    for(int i=0; i<MAX_MARCHES; i++) {\n"
"    	vec3 raypos = camerapos + raydir*distorigin;\n"
"        float distsurface = sphere(raypos);\n"
"        distorigin += distsurface;\n"
"        if(distorigin>MAX_DISTANCE || distsurface<COLLISION_DISTANCE) break;\n"
"    }\n"
"    \n"
"    return distorigin;\n"
"}\n"
"\n"
"// Get Normal\n"
"vec3 normal(vec3 raypos) {\n"
"	float dis = sphere(raypos);\n"
"    vec2 e = vec2(.01, 0);\n"
"    \n"
"    vec3 normal = dis - vec3(\n"
"        sphere(raypos-e.xyy),\n"
"        sphere(raypos-e.yxy),\n"
"        sphere(raypos-e.yyx));\n"
"    \n"
"    return normalize(normal);\n"
"}\n"
"\n"
"// Shade Scene\n"
"vec3 shade(vec3 march) {\n"
"	// Light Positions\n"
"    vec3 lightpositiona = vec3(0, 8, 0);\n"
"	vec3 lightpositionb = vec3(0, 0, 0);\n"
"    vec3 lightpositionc = vec3(0, -8, 0);\n"
"	// Animate Lights\n"
"    lightpositiona.xz += vec2(sin(iTime * 4.0), cos(iTime * 4.0))*4.0;\n"
"    lightpositionb.xz += vec2(sin(iTime * 4.0), cos(iTime * 4.0))*4.0;\n"
"    lightpositionc.xz += vec2(sin(iTime * 4.0), cos(iTime * 4.0))*4.0;\n"
"	// Compute Lighting\n"
"    vec3 lightinga = normalize(lightpositiona-march);\n"
"    vec3 lightingb = normalize(lightpositionb-march);\n"
"    vec3 lightingc = normalize(lightpositionc-march);\n"
"	// Compute Surface Normal\n"
"    vec3 surfacenormal = normal(march);\n"
"	// Compute Diffuse\n"
"    float diffuseshader = clamp(dot(surfacenormal, lightinga), 0.0, 1.0);\n"
"    float diffuseshadeg = clamp(dot(surfacenormal, lightingb), 0.0, 1.0);\n"
"    float diffuseshadeb = clamp(dot(surfacenormal, lightingc), 0.0, 1.0);\n"
"	// Compute Geometry\n"
"    float distancesurfa = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightinga);\n"
"    float distancesurfb = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingb);\n"
"    float distancesurfc = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingc);\n"
"	// Shade Geometry\n"
"    if(distancesurfa<length(lightpositiona-march)) diffuseshader *= 1.0;\n"
"    if(distancesurfa<length(lightpositionb-march)) diffuseshadeg *= 1.0;\n"
"    if(distancesurfb<length(lightpositionc-march)) diffuseshadeb *= 1.0;\n"
"    // Return Shading\n"
"    return vec3(diffuseshader, diffuseshadeg, diffuseshadeb);\n"
"}\n"
"\n"
"// ACES Tone Curve\n"
"vec3 acesFilm(const vec3 x) {\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n"
"}\n"
"\n"
"// Render the Image\n"
"vec4 mainImage(vec2 fragCoord )\n"
"{\n"
"	// Camera Orientation\n"
"	vec3 xdir = vec3(1,0,0);\n"
"	vec3 ydir = vec3(0,1,0);\n"
"	vec3 zdir = vec3(0,0,1);\n"
"	float FOV = 1.0;\n"
"	vec3 camerapos = vec3(0.0, 0.0, -4.5);\n"
"    camerapos = vec3(camerapos.x+((-iMouse.x+iResolution.x/2.0)/iResolution.x), camerapos.y+((-iMouse.y+iResolution.y/2.0)/iResolution.x), -4.5);\n"
"\n"
"    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n"
"    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n"
"	vec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n"
"	float collide = raymarch(camerapos, raydir);\n"
"\n"
"    // Pixel Color\n"
"    vec3 col = vec3(collide / 4.0);\n"
"\n"
"	// Compute and Shade\n"
"	float spheredistance = raymarch(camerapos, raydir);\n"
"    vec3 march = camerapos + raydir * spheredistance;\n"
"    vec3 diffuse = shade(march);\n"
"	\n"
"	// Finish the Image and Apply Tone Map\n"
"    col = vec3(acesFilm(diffuse));\n"
"\n"
"    // Output to Screen\n"
"    return vec4(col,1.0);\n"
"}\n"
"\n"
"\n"
"void main()\n"
"{\n"
"    vec2 fragCoord = vTextVary * iResolution.xy;\n"
"    gl_FragColor = mainImage(fragCoord); \n"
"}\n"
"\n"
"\n"
"\n";
